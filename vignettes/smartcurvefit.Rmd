---
title: "Getting Started with smartcurvefit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with smartcurvefit}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.width = 6,
  fig.height = 4
)
library(smartcurvefit)
```

## Introduction

The **smartcurvefit** package provides a *robust and efficient* framework for fitting nonlinear relationships between variables, even in the presence of outliers or heteroscedastic noise.

Traditional least-squares nonlinear regression can be sensitive to extreme values.  
`smartcurvefit` addresses this limitation through a **cross-validated loss selection** procedure powered by a **C++ backend** for fast and stable optimization.

Supported model types are:

- **Power law:**     *y ≈ a × x^b*
- **Exponential:**   *y ≈ a × exp(b × x)*
- **Logarithmic:**   *y ≈ a + b × log(x)*

Key features:

- Automatically estimates coefficients `a` and `b` - only data are required.  
- Compares **L1 (MAE)**, **L2 (MSE)**, and **Huber** losses using 5-fold cross-validation.  
- Selects the best-performing loss (based on RMSE or MAE) and refits the final model.  
- Provides user-friendly `print()`, `summary()`, `plot()`, and `predict()` methods.  

---

## How It Works

The core function `fit_model()` automatically fits the chosen model type under three loss functions: **L1**, **L2**, and **Huber**.  
Each is evaluated via 5-fold cross-validation. The loss with the lowest mean validation error (using `"rmse"` or `"mae"` as the metric) is selected, and the final model is refitted on the full dataset.

---

## Fitting a Power-Law Model

```{r}
set.seed(42)
x <- 1:30
y <- 2.3 * x^0.9 + rnorm(length(x), sd = 3)

fit_power <- fit_model(x, y, model_type = "power_law")

print(fit_power)      # concise output
summary(fit_power)    # extended diagnostics
plot(fit_power)       # fitted curve
```

You can also view residuals to check fit quality:

```{r fig.height=8}
plot(fit_power, show_residuals = TRUE)
```

---

## Fitting an Exponential Model

```{r}
set.seed(123)
x <- 1:30
y_exp <- 2.5 * exp(0.08 * x) + rnorm(length(x), sd = 5)

fit_exp <- fit_model(x, y_exp, model_type = "exponential")

summary(fit_exp)
plot(fit_exp, col_points = "darkred")
```

---

## Fitting a Logarithmic Model

```{r}
set.seed(321)
x <- 1:50
y_log <- 3 + 2 * log(x) + rnorm(length(x), sd = 2)

fit_log <- fit_model(x, y_log, model_type = "logarithmic")

summary(fit_log)
plot(fit_log, col_points = "darkgreen")
```

---

## Making Predictions

The `predict()` method generates fitted or new predictions for any model type.

```{r}
set.seed(42)
x <- 1:30
y <- 2.3 * x^0.9 + rnorm(length(x), sd = 3)
fit_power <- fit_model(x, y, model_type = "power_law")

x_new <- seq(1, 30, by = 0.5)
y_pred <- predict(fit_power, newdata = x_new)

plot(x, y, pch = 19, col = "steelblue",
     main = "Power-law Model with Predictions",
     xlab = "x", ylab = "y")
lines(x_new, y_pred, col = "red", lwd = 2)
```

The red curve shows the predicted values computed on a dense grid of `x_new` points.

---

## Cross-Validation Results

Each fitted object stores detailed **cross-validation results** for all candidate losses:

```{r}
fit_power$cv_results
```

and the **full-data refits** under each loss:

```{r}
fit_power$all_results
```

- The selected loss is reported in `fit_power$chosen_loss`, chosen based on the lowest average validation error.

---

## Error Handling and Warnings

`fit_model()` includes extensive input validation and informative warnings.

Requirements:

- `x` and `y` must be numeric, equal length, and contain ≥3 points.  
- No missing (`NA`, `NaN`) or infinite values.  
- For `"power_law"` and `"logarithmic"`, `x` must be strictly positive.

Possible warnings:

- **Unstable fits** when `x < 1` in power-law models.  
- **Extreme values** risking overflow or underflow.  
- **Large datasets**, triggering performance notes.  
- **Omitted model_type**, defaults to `"power_law"`.

---

## Conclusion

The **smartcurvefit** package provides a practical and statistically robust approach to nonlinear modeling.  
By combining multiple loss functions, cross-validation, and a C++ backend, it offers fast, reliable, and interpretable model fitting.

It is well-suited for:

- Exploratory data analysis and curve comparison,  
- Teaching robust nonlinear regression,  
- Applied analytics pipelines needing outlier resistance.

For more details, refer to:

- `?fit_model`  
- `?print.smartFit`  
- `?summary.smartFit`  
- `?plot.smartFit`  
- `?predict.smartFit`

---
